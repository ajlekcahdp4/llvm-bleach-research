#import "/utils/todo.typ": TODO
#import "@preview/codly:1.3.0": *
#import "@preview/codly-languages:0.1.1": *
#show: codly-init.with()

= Описание практической части
В данной главе представлена имплементация идей и подходов к решению задачи
подъёма MIR кода архитектуры RISC-V в LLVM IR, описанных в @chapt-solution.
Построена модель инструкций этой архитектуры и описано применение её для
трансляции RISC-V кода в высокоуровневое представление LLVM IR.

== Модель инструкции RISC-V <chapt-instruction-model>
Начнём с построения модели инструкции архитектуры RISC-V, представленной в
@chapt-instr-model. Как уже было сказано мы разделим все инструкции из
спецификации RISC-V на несколько классов, все инструкции внутри которых будут
обрабатываться одинаково. Опишем все выделенные в данной работе классы
инструкций.

=== Регулярные инструкции
Класс "регулярных" инструкций был описан в @chapt-instr-model, в этот класс
попадёт большинство инструкций из спецификации, в том числе `ADD`, `SLLI`, `MUL` и
т.д. В терминах предикатов из MIR инструкция принадлежит к этому классу если
выражение на @regular-class-code верно. Как уже было отмечено, инструкции этого
класса поднимаются простой итеративной заменой на вызовы соответствующих
функций.

#codly(zebra-fill: luma(240))
#figure(
  caption: [Условие принадлежности к классу регулярных инструкций],
)[
#set text(size: 1.2em)
```CPP
  bool is_regular_instruction(const MachineInstr &minst) {
    return !minst.isTerminator() && !minst.isCall() && !minst.isReturn();
  }
  ```
] <regular-class-code>

=== Инструкции безусловного перехода
Инструкции безусловного перехода -- операции, передающие управление другому
базовому блоку сразу по их достижению исполнителем. Условием принадлежности к
этому классу в MIR является удовлетворение предикату на @br-class-code.
#figure(
  caption: [Условие принадлежности к классу инструкций безусловного перехода],
)[
#set text(size: 1.2em)
```CPP
bool is_unconditional_branch(const MachineInstr &minst) {
  return minst.isUnconditionalBranch();
}
```
] <br-class-code>

Перевод инструкций из этого класса не выполняется путём простой замены этой
инструкции на инструкцию безусловного перехода из LLVM IR #footnote[Инструкция `br` -- https://llvm.org/docs/LangRef.html#br-instruction] с
блоком назначения, полученным из соответствующего операнда `MachineInstr`. Таким
образом простой пример кода с инструкцией безусловного перехода `J` из
@br-mir-code переводится в LLVM IR, представленный на @br-llvm-code.

#grid(columns: (50%, 50%), gutter: 5pt, [
#figure(caption: [Пример MIR кода с инструкцией `J`])[
```MIR
bb.0:
  ...
bb.1:
  ...
  J bb.0
```
] <br-mir-code>
], [
#figure(caption: [Пример MIR кода с инструкцией `J`])[
```LLVM
block0:
  ...
block1:
  ...
  br label %block0
```
] <br-llvm-code>
])

=== Инструкции условного перехода
Инструкциями условного перехода назовём инструкции, передающие управление другим
базовым блокам при соблюдении определённых условий. В терминах предикатов MIR
инструкция принадлежит этому классу если верен предикат описанный на
@cond-br-class-code.
#figure(
  caption: [Условие принадлежности к классу инструкций условного перехода],
)[
#set text(size: 1.2em)
```CPP
  bool is_conditional_branch(const MachineInstr &minst) {
    return minst.isConditionalBranch();
  }
```
] <cond-br-class-code>

В случае MIR определить базовый блок, которому возможна пердача управления легко
обратившись к операндам `MachineInstr`. Условие перехода, однако, определить из
описания LLVM невозможно. Воспользуемся тем, что условием всех условных
переходов в архитектуре RISC-V является результат сравнения двух регистров #footnote[Некоторые инструкции из расширения C (например `C_BEQZ`) имеют один входной
регистр, который они сравнивают с нулём, однако они не требуют специальной
обработки и являются частным случаем инструкций условного перехода в нашей
классификации]. Будем получать усовие перехода для инструкций через
сопоставление каждой из этих функций булевой функции на LLVM IR по следующему
принципу: Значение всех входных операндов-регистров инструкции (выходных
операндов нет) передаются в функцию как аргументы. Функция выполняет
соответствующую инструкции проверку над этими операндами и возвращает результат
в виде булевого значения. Далее вставляется инструкция условного перехода LLVM
IR , условием которой является значение, полученное из вызова описанной выше
функции. Назначением перехода будет соответствовать базовый блок, полученный из
последнего операнда инструкции. В отличии от инструкций условного перехода,
инструкция условного перехода `br` в LLVM IR имеет ещё один операнд -- базовый
блок, в который она передаст управление если условие не выполнено. Значение
данного операнда будем выставлять в следующий за этой инструкцией базовый
блок/инструкцию.

Приведём пример такого сопоставления для инструкции `BLT` (Branch if Less Then
-- Переход если меньше или равно). Данная инструкция принимает на вход два
регистра и совершает переход если значение в первом регистре меньше чем во
втором. Соответствующая данной инструкции функция в LLVM IR будет иметь вид:
#figure(caption: [Функция-условие перехода, соответствующая инструкции `BLT`])[
#set text(size: 1.2em)
```LLVM
define i1 @BLT(i64 %0, i64 %1) {
  %3 = icmp slt i64 %0, %1
  ret i1 %3
}

```
] <blt-code>

Тогда при переводе следующего кода, представленного на @blt-mir-code, получим
LLVM IR представленный на @blt-llvm-code.
#figure(caption: [Пример MIR кода с инструкцией `BLT` для перевода в LLVM IR])[
#set text(size: 1.2em)
```MIR
bb.0:
  ...
  BLT $x10, $X11, bb.0
bb.1:
  ...

```
] <blt-mir-code>

#figure(caption: [Полученный при переводе инструкции `BLT` LLVM IR])[
#set text(size: 1.2em)
```LLVM
block0:
  ...
  %cond = i1 call @BLT(i64 %x10, i64 %x11)
  br i1 %cond, label %block0, label %block1
block1:
  ...
```
] <blt-llvm-code>

=== Инструкции вызова функций
Вызов функции -- передача управления определённой функции с последующим
возвратом управления в точку вызова. В отличии от инструкций условного и
безусловного перехода, инструкции вызова не прерывают базовые блоки и могут
находиться внутри них. С точки зрения MIR инструкция принадлежит этому классу
если выполняется предикат, представленный на @call-class-code:
#figure(caption: [Условие принадлежности к классу инструкций вызова])[
#set text(size: 1.2em)
```CPP
boo is_call(const MachineInstr &minst) {
  return minst.isCall();
}

```
] <call-class-code>

Работа с вызовами функций в нашем трансляторе намного интереснее работы с
другими классами инструкций. Как было отмечено в @chapt-abi-concept, вместо
попыток воспроизвести изначальную сигнатуру функции мы будем пользоваться
собственным соглашением о вызовах, в котором функции общаются друг с другом,
передавая единственный аргумент -- ссылку на текущий контекст исполнения.

Работа с контекстом исполнения означает, что на момент вызова и возврата из
функций в этом контексте должно храниться актуальное состояние регистров. Таким
образом, необходимо записывать обновлённые значения каждого из регистров в
контекст. При переводе инструкции вызова `JAL` в RISC-V мы будем заменять её
вызовом соотвтетсвующей функции в LLVM IR (см. @call-mir-code и
@call-llvm-code).
#figure(caption: [Пример MIR кода с инструкцией `JAL` для перевода в LLVM IR])[
#codly(zebra-fill: none)
#set text(size: 1.2em)
```MIR
  JAL bar

```
] <call-mir-code>

#figure(caption: [Полученный при переводе инструкции `JAL` LLVM IR])[
#set text(size: 1.2em)
```LLVM
  call void @bar(ptr %state)
```
] <call-llvm-code>

#codly(zebra-fill: luma(240))

== Имплементация транслятора
Наконец опишем полный алгоритм работы транслятора из RISC-V MIR кода в LLVM IR,
основанного на описанных выше принципах (код доступен на @bleach-github).

=== Конфигурация целевой архитектуры
Опишем конкретный использованный формат описания инструкций, о котором
говорилось в @chapt-instruction-model. Как было сказано выше, большинству
инструкций из спецификации RISC-V сопоставляются функции из LLVM IR. В ходе
работы было принято решение вынести данное описание за пределы исходного кода
инструмента. Таким образом пользователь сможет настраивать инструмент для
подъёма необходимой ему конфигурации RISC-V процессора без необходимости
перекомпиляции проекта из исходного кода.

В качестве языка для описания инструкций был выбран язык разметки YAML (см.
@yaml-spec). Такой выбор был сделан из-за распространённости инструментов для
работы с этим представлением и его простоты к написанию.

Формат YAML конфигурации был выбран следующим:
- Верхнеуровневый ключ `instructions` начинает перечисление описаний для каждой из
  необходимых инструкций
- Каждая из инструкций в свою очередь хранит текстовое представление
  соответствующей ей функции LLVM IR под ключём `func`.

Таким образом, пример входной конфигурации архитектуры можно увидеть на
@yaml-config-example. Конфигурационный файл в заданном формате считывается транслятором и описанные в
нём функции используются для подъёма MIR кода RISC-V.
#figure(
  caption: [Пример конфигурации архитектуры в формате YAML для инструкций `OR` и `XOR`],
)[
#set text(size: 1.2em)
```yaml
instructions:
  - OR:
      func: |
        define i64 @OR(i64 %0, i64 %1) {
          %3 = or i64 %1, %0
          ret i64 %3
        }
  - XOR:
      func: |
        define i64 @XOR(i64 %0, i64 %1) {
          %3 = xor i64 %1, %0
          ret i64 %3
        }
```
] <yaml-config-example>


=== Алгоритм трансляции

=== Работа со стеком

//Детально опишем предложенный алгоритм подъёма функций:
//+ При подъёме заданной MIR функции создадим новую LLVM IR функцию с тем же названием и представленной на @func-abi-signature сигнатурой.
//+ Перед подъёмом

== Результаты
