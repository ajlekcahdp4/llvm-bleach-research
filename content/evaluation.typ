#import "/utils/todo.typ": TODO
#import "@preview/codly:1.3.0": *
#import "@preview/codly-languages:0.1.1": *
#show: codly-init.with()

= Описание практической части
В данной главе представлена имплементация идей и подходов к решению задачи
подъёма MIR кода архитектуры RISC-V в LLVM IR, описанных в @chapt-solution.
Построена модель инструкций этой архитектуры и описано применение её для
трансляции RISC-V кода в высокоуровневое представление LLVM IR.

== Модель инструкции RISC-V
Начнём с построения модели инструкции архитектуры RISC-V, представленной в
@chapt-instr-model. Как уже было сказано мы разделим все инструкции из
спецификации RISC-V на несколько классов, все инструкции внутри которых будут
обрабатываться одинаково. Опишем все выделенные в данной работе классы
инструкций.

=== Регулярные инструкции
Класс "регулярных" инструкций был описан в @chapt-instr-model, в этот класс
попадёт большинство инструкций из спецификации, в том числе `ADD`, `SLLI`, `MUL` и
т.д. В терминах предикатов из MIR инструкция принадлежит к этому классу если
выражение на @regular-class-code верно. Как уже было отмечено, инструкции этого
класса поднимаются простой итеративной заменой на вызовы соответствующих
функций.

#codly(zebra-fill: luma(240))
#figure(
  caption: [Условие принадлежности к классу регулярных инструкций],
)[
#set text(size: 1.2em)
```CPP
  bool is_regular_instruction(const MachineInstr &minst) {
    return !minst.isTerminator() && !minst.isCall() && !minst.isReturn();
  }
  ```
] <regular-class-code>

=== Инструкции безусловного перехода
Инструкции безусловного перехода -- операции, передающие управление другому
базовому блоку сразу по их достижению исполнителем. Условием принадлежности к
этому классу в MIR является удовлетворение предикату на @br-class-code.
#figure(
  caption: [Условие принадлежности к классу инструкций безусловного перехода],
)[
#set text(size: 1.2em)
```CPP
bool is_unconditional_branch(const MachineInstr &minst) {
  return minst.isUnconditionalBranch();
}
```
] <br-class-code>

Перевод инструкций из этого класса не выполняется путём простой замены этой
инструкции на инструкцию безусловного перехода из LLVM IR #footnote[Инструкция `br` -- https://llvm.org/docs/LangRef.html#br-instruction] с
блоком назначения, полученным из соответствующего операнда `MachineInstr`. Таким
образом простой пример кода с инструкцией безусловного перехода `J` из
@br-mir-code переводится в LLVM IR, представленный на @br-llvm-code.

#grid(columns: (50%, 50%), gutter: 5pt, [
#figure(caption: [Пример MIR кода с инструкцией `J`])[
```MIR
bb.0:
  ...
bb.1:
  ...
  J bb.0
```
] <br-mir-code>
], [
#figure(caption: [Пример MIR кода с инструкцией `J`])[
```LLVM
block0:
  ...
block1:
  ...
  br label %block0
```
] <br-llvm-code>
])

=== Инструкции условного перехода
Инструкциями условного перехода назовём инструкции, передающие управление другим
базовым блокам при соблюдении определённых условий. В терминах предикатов MIR
инструкция принадлежит этому классу если верен предикат описанный на
@cond-br-class-code.
#figure(
  caption: [Условие принадлежности к классу инструкций условного перехода],
)[
#set text(size: 1.2em)
```CPP
  bool is_conditional_branch(const MachineInstr &minst) {
    return minst.isConditionalBranch();
  }
```
] <cond-br-class-code>

В случае MIR определить базовый блок, которому возможна пердача управления легко
обратившись к операндам `MachineInstr`. Условие перехода, однако, определить из
описания LLVM невозможно. Воспользуемся тем, что условием всех условных
переходов в архитектуре RISC-V является результат сравнения двух регистров #footnote[Некоторые инструкции из расширения C (например `C_BEQZ`) имеют один входной
регистр, который они сравнивают с нулём, однако они не требуют специальной
обработки и являются частным случаем инструкций условного перехода в нашей
классификации]. Будем получать усовие перехода для инструкций через
сопоставление каждой из этих функций булевой функции на LLVM IR по следующему
принципу: Значение всех входных операндов-регистров инструкции (выходных
операндов нет) передаются в функцию как аргументы. Функция выполняет
соответствующую инструкции проверку над этими операндами и возвращает результат
в виде булевого значения. Далее вставляется инструкция условного перехода LLVM
IR , условием которой является значение, полученное из вызова описанной выше
функции. Назначением перехода будет соответствовать базовый блок, полученный из
последнего операнда инструкции. В отличии от инструкций условного перехода,
инструкция условного перехода `br` в LLVM IR имеет ещё один операнд -- базовый
блок, в который она передаст управление если условие не выполнено. Значение
данного операнда будем выставлять в следующий за этой инструкцией базовый
блок/инструкцию.

Приведём пример такого сопоставления для инструкции `BLT` (Branch if Less Then
-- Переход если меньше или равно). Данная инструкция принимает на вход два
регистра и совершает переход если значение в первом регистре меньше чем во
втором. Соответствующая данной инструкции функция в LLVM IR будет иметь вид:
#figure(caption: [Функция-условие перехода, соответствующая инструкции `BLT`])[
#set text(size: 1.2em)
```LLVM
define i1 @BLT(i64 %0, i64 %1) {
  %3 = icmp slt i64 %0, %1
  ret i1 %3
}

```
] <blt-code>

Тогда при переводе следующего кода, представленного на @blt-mir-code, получим
LLVM IR представленный на @blt-llvm-code.
#figure(caption: [Пример MIR кода с инструкцией `BLT` для перевода в LLVM IR])[
#set text(size: 1.2em)
```MIR
bb.0:
  ...
  BLT $x10, $X11, bb.0
bb.1:
  ...

```
] <blt-mir-code>

#figure(caption: [Полученный при переводе инструкции `BLT` LLVM IR])[
#set text(size: 1.2em)
```LLVM
block0:
  ...
  %cond = i1 call @BLT(i64 %x10, i64 %x11)
  br i1 %cond, label %block0, label %block1
block1:
  ...
```
] <blt-llvm-code>
== Имплементация транслятора
== Результаты
