#import "/utils/todo.typ": TODO
#import "@preview/codly:1.3.0": *
#import "@preview/codly-languages:0.1.1": *
#show: codly-init.with()

= Описание практической части
В данной главе представлена имплементация идей и подходов к решению задачи
подъёма MIR кода архитектуры RISC-V в LLVM IR, описанных в @chapt-solution.
Построена модель инструкций этой архитектуры и описано применение её для
трансляции RISC-V кода в высокоуровневое представление LLVM IR.

== Модель инструкции RISC-V <chapt-instruction-model>
Начнём с построения модели инструкции архитектуры RISC-V, представленной в
@chapt-instr-model. Как уже было сказано мы разделим все инструкции из
спецификации RISC-V на несколько классов, все инструкции внутри которых будут
обрабатываться одинаково. Опишем все выделенные в данной работе классы
инструкций.

=== Регулярные инструкции
Класс "регулярных" инструкций был описан в @chapt-instr-model, в этот класс
попадёт большинство инструкций из спецификации, в том числе `ADD`, `SLLI`, `MUL` и
т.д. В терминах предикатов из MIR инструкция принадлежит к этому классу если
выражение на @regular-class-code верно. Как уже было отмечено, инструкции этого
класса поднимаются простой итеративной заменой на вызовы соответствующих
функций.

#codly(zebra-fill: luma(240))
#figure(
  caption: [Условие принадлежности к классу регулярных инструкций],
)[
#set text(size: 1.2em)
```CPP
  bool is_regular_instruction(const MachineInstr &minst) {
    return !minst.isTerminator() && !minst.isCall() && !minst.isReturn();
  }
  ```
] <regular-class-code>

=== Инструкции безусловного перехода
Инструкции безусловного перехода -- операции, передающие управление другому
базовому блоку сразу по их достижению исполнителем. Условием принадлежности к
этому классу в MIR является удовлетворение предикату на @br-class-code.
#figure(
  caption: [Условие принадлежности к классу инструкций безусловного перехода],
)[
#set text(size: 1.2em)
```CPP
bool is_unconditional_branch(const MachineInstr &minst) {
  return minst.isUnconditionalBranch();
}
```
] <br-class-code>

Перевод инструкций из этого класса не выполняется путём простой замены этой
инструкции на инструкцию безусловного перехода из LLVM IR #footnote[Инструкция `br` -- https://llvm.org/docs/LangRef.html#br-instruction] с
блоком назначения, полученным из соответствующего операнда `MachineInstr`. Таким
образом простой пример кода с инструкцией безусловного перехода `J` из
@br-mir-code переводится в LLVM IR, представленный на @br-llvm-code.

#grid(columns: (50%, 50%), gutter: 5pt, [
#figure(caption: [Пример MIR кода с инструкцией `J`])[
```MIR
bb.0:
  ...
bb.1:
  ...
  J bb.0
```
] <br-mir-code>
], [
#figure(caption: [Пример MIR кода с инструкцией `J`])[
```LLVM
block0:
  ...
block1:
  ...
  br label %block0
```
] <br-llvm-code>
])

=== Инструкции условного перехода
Инструкциями условного перехода назовём инструкции, передающие управление другим
базовым блокам при соблюдении определённых условий. В терминах предикатов MIR
инструкция принадлежит этому классу если верен предикат описанный на
@cond-br-class-code.
#figure(
  caption: [Условие принадлежности к классу инструкций условного перехода],
)[
#set text(size: 1.2em)
```CPP
  bool is_conditional_branch(const MachineInstr &minst) {
    return minst.isConditionalBranch();
  }
```
] <cond-br-class-code>

В случае MIR определить базовый блок, которому возможна пердача управления легко
обратившись к операндам `MachineInstr`. Условие перехода, однако, определить из
описания LLVM невозможно. Воспользуемся тем, что условием всех условных
переходов в архитектуре RISC-V является результат сравнения двух регистров #footnote[Некоторые инструкции из расширения C (например `C_BEQZ`) имеют один входной
регистр, который они сравнивают с нулём, однако они не требуют специальной
обработки и являются частным случаем инструкций условного перехода в нашей
классификации]. Будем получать усовие перехода для инструкций через
сопоставление каждой из этих функций булевой функции на LLVM IR по следующему
принципу: Значение всех входных операндов-регистров инструкции (выходных
операндов нет) передаются в функцию как аргументы. Функция выполняет
соответствующую инструкции проверку над этими операндами и возвращает результат
в виде булевого значения. Далее вставляется инструкция условного перехода LLVM
IR , условием которой является значение, полученное из вызова описанной выше
функции. Назначением перехода будет соответствовать базовый блок, полученный из
последнего операнда инструкции. В отличии от инструкций условного перехода,
инструкция условного перехода `br` в LLVM IR имеет ещё один операнд -- базовый
блок, в который она передаст управление если условие не выполнено. Значение
данного операнда будем выставлять в следующий за этой инструкцией базовый
блок/инструкцию.

Приведём пример такого сопоставления для инструкции `BLT` (Branch if Less Then
-- Переход если меньше или равно). Данная инструкция принимает на вход два
регистра и совершает переход если значение в первом регистре меньше чем во
втором. Соответствующая данной инструкции функция в LLVM IR будет иметь вид:
#figure(caption: [Функция-условие перехода, соответствующая инструкции `BLT`])[
#set text(size: 1.2em)
```LLVM
define i1 @BLT(i64 %0, i64 %1) {
  %3 = icmp slt i64 %0, %1
  ret i1 %3
}

```
] <blt-code>

Тогда при переводе следующего кода, представленного на @blt-mir-code, получим
LLVM IR представленный на @blt-llvm-code.
#figure(caption: [Пример MIR кода с инструкцией `BLT` для перевода в LLVM IR])[
#set text(size: 1.2em)
```MIR
bb.0:
  ...
  BLT $x10, $X11, bb.0
bb.1:
  ...

```
] <blt-mir-code>

#figure(caption: [Полученный при переводе инструкции `BLT` LLVM IR])[
#set text(size: 1.2em)
```LLVM
block0:
  ...
  %cond = i1 call @BLT(i64 %x10, i64 %x11)
  br i1 %cond, label %block0, label %block1
block1:
  ...
```
] <blt-llvm-code>

=== Инструкции вызова функций
Вызов функции -- передача управления определённой функции с последующим
возвратом управления в точку вызова. В отличии от инструкций условного и
безусловного перехода, инструкции вызова не прерывают базовые блоки и могут
находиться внутри них. С точки зрения MIR инструкция принадлежит этому классу
если выполняется предикат, представленный на @call-class-code:
#figure(caption: [Условие принадлежности к классу инструкций вызова])[
#set text(size: 1.2em)
```CPP
boo is_call(const MachineInstr &minst) {
  return minst.isCall();
}

```
] <call-class-code>

Работа с вызовами функций в нашем трансляторе намного интереснее работы с
другими классами инструкций. Как было отмечено в @chapt-abi-concept, вместо
попыток воспроизвести изначальную сигнатуру функции мы будем пользоваться
собственным соглашением о вызовах, в котором функции общаются друг с другом,
передавая единственный аргумент -- ссылку на текущий контекст исполнения.

Работа с контекстом исполнения означает, что на момент вызова и возврата из
функций в этом контексте должно храниться актуальное состояние регистров. Таким
образом, необходимо записывать обновлённые значения каждого из регистров в
контекст. При переводе инструкции вызова `JAL` в RISC-V мы будем заменять её
вызовом соотвтетсвующей функции в LLVM IR (см. @call-mir-code и
@call-llvm-code).
#figure(caption: [Пример MIR кода с инструкцией `JAL` для перевода в LLVM IR])[
#codly(zebra-fill: none)
#set text(size: 1.2em)
```MIR
  JAL bar

```
] <call-mir-code>

#figure(caption: [Полученный при переводе инструкции `JAL` LLVM IR])[
#set text(size: 1.2em)
```LLVM
  call void @bar(ptr %state)
```
] <call-llvm-code>

#codly(zebra-fill: luma(240))

== Имплементация транслятора
Наконец опишем полный алгоритм работы транслятора из RISC-V MIR кода в LLVM IR,
основанного на описанных выше принципах (код доступен на @bleach-github).

=== Конфигурация целевой архитектуры
Опишем конкретный использованный формат описания инструкций, о котором
говорилось в @chapt-instruction-model. Как было сказано выше, большинству
инструкций из спецификации RISC-V сопоставляются функции из LLVM IR. В ходе
работы было принято решение вынести данное описание за пределы исходного кода
инструмента. Таким образом пользователь сможет настраивать инструмент для
подъёма необходимой ему конфигурации RISC-V процессора без необходимости
перекомпиляции проекта из исходного кода.

В качестве языка для описания инструкций был выбран язык разметки YAML (см.
@yaml-spec). Такой выбор был сделан из-за распространённости инструментов для
работы с этим представлением и его простоты к написанию. YAML (рекурсивный
акроним для YAML Ain't Markup Language) -- Человекочитаемый язык сериализации
данных, разработанный в 2001 году. YAML используется для написания
конфигурационных файлов, а так же для хранения и передачи данных. Перечислим
главные концепции YAML, которыми далее будем пользоваться:
- *Скаляры* -- самый примитивный из типов данных, используемых в YAML. Скалярами
  могут являться целый числа, числа с плавающей точкой или строки. Строки могут
  содержать символы перехода на новую строку, а ковычки являются опциональными.
  Особым видом скаляров является `null`, обозначающий отсутствие значения.
- *Сопоставления (словари)* -- тип данных, представляющий собой неупорядоченный
  набор, ассоциирующий ключи со значениями. Сопоставления задаются в YAML через
  значение, отделённое от своего ключа двоеточием. Ключи обязаны быть уникальными,
  а значения могут иметь любой из доступных типов: скаляры, другие словари или
  списки.
- *Списки (коллекции)* -- объекты, представляющие собой упорядоченный набор из
  любых данных. YAML предоставляет два формата задания списков: блочный и
  однострочный. В блочном формате элементы списка задаются на новой строке,
  начинающейся с символа `-`, а в однострочном пишутся внутри квадратных скобок и
  разделяются запятыми (см. @yaml-seq-example).
#figure(
  caption: [Пример списков в YAML (Здесь и `foo`, и `bar` хранят последовательность чисел от
  1 до 3)],
)[
#set text(size: 1.2em)
```yaml
foo:
- 1
- 2
- 3
bar: [1, 2, 3]
```
] <yaml-seq-example>

Формат YAML конфигурации был выбран следующим:
- Верхнеуровневый ключ `instructions` начинает перечисление описаний для каждой из
  необходимых инструкций
- Каждая из инструкций в свою очередь хранит текстовое представление
  соответствующей ей функции LLVM IR под ключём `func`.

Таким образом, пример входной конфигурации архитектуры можно увидеть на
@yaml-config-example. Конфигурационный файл в заданном формате считывается
транслятором и описанные в нём функции используются для подъёма MIR кода RISC-V.
Функции для инструкций условного перхода задаются в том же формате, пример для
инструкции `BLT` представлен на @yaml-cond-br-example.
#figure(
  caption: [Пример конфигурации архитектуры в формате YAML для инструкций `OR` и `XOR`],
)[
#set text(size: 1.2em)
```yaml
instructions:
  - OR:
      func: |
        define i64 @OR(i64 %0, i64 %1) {
          %3 = or i64 %1, %0
          ret i64 %3
        }
  - XOR:
      func: |
        define i64 @XOR(i64 %0, i64 %1) {
          %3 = xor i64 %1, %0
          ret i64 %3
        }
```
] <yaml-config-example>

#figure(
  caption: [Пример конфигурации архитектуры в формате YAML для инструкции `BLT`],
)[
#set text(size: 1.2em)
```yaml
instructions:
  - BLT:
      func: |
        define i1 @BLT(i64 %0, i64 %1) {
          %3 = icmp slt i64 %0, %1
          ret i1 %3
        }
```
] <yaml-cond-br-example>

=== Алгоритм трансляции
Наконец, последовательно опишем алгоритм трансляции модуля LLVM MIR.

==== Создание объектов функции и типа контекста
Начнём с
построения класса контекста исполнения `state`. На данный момент данный класс
будет хранить в себе исключительно состояний регистров. Таким образом создаётся
структура (`struct`) в LLVM IR, хранящая в себе массив значений регистров.
Массив используется вместо контейнера, потому что все регистры общего назначения
архитектуры RISC-V пронумерованы (От `X0` до `X31` в случае `rv32i`/`rv64i` и от `X0` до `X15` в
случае `rv32e`/`rv64e`). Ширина, необходимая для хранения значения регистров
выбирается в зависимости от того, поднимается ли код 32-битного или с 64-битного
варианта архитектуры RISC-V #footnote[Аналогично возможна поддежрка 128-битной архитектуры RISC-V].
Таким образом структура контекста в LLVM IR будет иметь вид:
#figure(caption: [Структура контекста для архитектуры `rv64i`])[
#set text(size: 1.2em)
```LLVM
%state = type { [32 x i64] }
```
]

Как было описано в @chapt-intro-mir, Модули в MIR состоят из машинных функций
(класс `MachineFunction` в библиотеке LLVM). Прежде всего для каждой машинной
функции необходимо создать соответствующую функцию LLVM IR, с сигнатурой,
описанной в @chapt-abi-concept. Т.е. создаётся функция с тем же именем, что и у
машинной, которая имеет пустое возвращаемое значение `void` и единственный
аргумент `%regstate` типа `ptr`.

Далее для всех базовых блоков изначальной MIR функции необходимо создать новый
базовые блоки в LLVM IR. Далее возможно добавление новых базовых блоков для
работы с особенностями LLVM IR, но функция будет иметь как минимум столько же
блоков, сколько исходная `MachineFunction`. В процессе создания базовых блоков
необходимо строить отображение из старых машинных блоков в новые блоки LLVM IR.
Данная информация будет необходима при дальнейшей работе с потоком управления.


==== Выгрузка регистров
Перед началом итеративного подъёма инструкций в MIR функции необходимо выгрузить
значения регистров из контекста. Для этого в LLVM необходимо сначала получить
адресс массива регистров (назовём его `%GPRS`) из контекста. Это делается через
инструкцию `getelementptr`, принимающей в нашем случае два индекса. Первый индекс
-- индекс структуры контекста в возможном массиве этих контекстов, скрывающимся
под указателем `%regstate`, полученным как аргумент функции. В нашем случае этот
индекс всегда равен нулю. Второй индекс обозначает номер элемента в структуре `state`.
В нашем случае массив регистров -- первый элемент структуры, поэтому данный
индекс также будет равен нулю. Теперь необходимо получить адрес каждого из
регистров (назовём его `%x_i_ptr`, где `i` -- номер регистра), хранимых в
массиве, указатель на который был только что получен. Для этого снова
используется инструкция `getelementptr` первый индекс которой равен нулю как
индекс единственного массива в возможном массиве массивов `%GPRS`, а второй
равен номеру регистра. После этого загружается значение регистра `%x_i` из
указателя `%x_i_ptr`. Загрузка производится при помощи инструкции `load`,
загружаемый тип которой выставлен в целочисленной число с размером в ширину
регистра (т.е. `i64` для `rv64`).

Теперь полученные из контекста значения регистров складываются на стек. Для
этого необходимо выделить для них стековую ячейку `%x_i_stack`. Сделаем это при
помощи инструкции `alloca` с соответствующим регистру типом. Теперь можно
записать выгруженное ранее значение регистра в подготовленную стековую ячейку
при помощи инструкции `store`. Описанные операции выгрузки значений из
контекста, выделения места на стеке и сохранение на стек необходимо повторить
для всех используемых регистров. Полученный LLVM IR код представлен на @reg-mat-code.

#figure(caption: [Код аллокации стекового окна и выгрузки регистров для функции `foo`])[
#set text(size: 1.3em)
```LLVM
define void @foo(ptr %regstate) {
  %GPRS = getelementptr %state, ptr %regstate, i32 0, i32 0
  %x_0_ptr = getelementptr inbounds [32 x i64], ptr %GPRS, i32 0, i32 0
  %x_0_stack = alloca i64, align 8
  %x_0 = load i64, ptr %x_0_ptr, align 8
  store i64 %x_0, ptr %x_0_stack, align 8
  %x_1_ptr = getelementptr inbounds [32 x i64], ptr %GPRS, i32 0, i32 1
  %x_1_stack = alloca i64, align 8
  %x_1 = load i64, ptr %x_1_ptr, align 8
  store i64 %x_1, ptr %x_1_stack, align 8
  ...
  ret void
}
```
] <reg-mat-code>

==== Замена инструкций

=== Работа со стеком

//Детально опишем предложенный алгоритм подъёма функций:
//+ При подъёме заданной MIR функции создадим новую LLVM IR функцию с тем же названием и представленной на @func-abi-signature сигнатурой.
//+ Перед подъёмом

== Результаты
