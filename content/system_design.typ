#import "/utils/todo.typ": TODO
= Исследование и построение решения задачи
В данной главе мы обсудим возможные решения проблем существующих лифтеров в LLVM
IR. Отличительной чертой предложенного подхода будет являться минимализация
ручного описания архитектуры.

== Использование описания архитектуры из LLVM <mir-desc>

Прежде всего мы решим проблемы поддержания низкоуровневой информации об
инструкциях, регистрах и расширениях. Как уже было сказано, многие существующие
инструмены поддерживают собственное описание инструкций для работы с машинным
кодом. Предлагается полностью решить эту проблему, переиспользовав уже
существующие описания. LLVM, являясь компиляторной инфраструктурой, обязан уметь
корректно порождать и читать машинный код. Большим плюсом этой платформы
является развитое описание всех инструкций и всех расширений RISC-V (Как и
подавляющего большинства других архитектур, таких как X86, ARM, MIPS и даже
SPIRV). LLVM обладает информацие о кодировках, операндах, семантике ассемблера
всех инструкций из большинства существующих расширений RISC-V. Вместо того,
чтобы описывать всю эту информацию вручную предлагается преиспользовать
существующее описание инструкций из LLVM. Большим плюсом такого подхода является
снижение вероятности ошибки. Все расширения, поддержанные в LLVM косвенно
тестируются компилятором `clang`. Это означает, что если в описании некого
расширения допущена ошибка, то компиляция под архитектуру процессора,
включающего это расширение либо произойдёт ошибка, либо исполнение программы
будет некорректным, что приведёт к мотивации исправить недочёт в описании для
стабильной работы компилятора `clang`. Таким образом в нашем инструменте будет
доступна корректная информация о всех расширениях RISC-V, поддержанных
компилятором `clang` (Таких расширений на момент написания данной работы больше
100).

Рассмотрим подробнее средства средства взаимодействия с машинным описанием,
предоставляемые библиотекой LLVM. Как уже было сказано во введении, MIR является
внутренним представлением машинного кода в LLVM. Самым важным из примитивов
машинной абстракции MIR является класс инструкции `MachineInstr`. Он
предоставляет такую информацию о конкретной инструкции в коде, как её тип, число
и типы её операндов и т.д, но является общим для инструкций из всех поддержанных
архитектур и расширений RISC-V. С помощью этого объекта можно определить
является ли инструкция передачей управления, работой с памятью или
арифметической операцией. Также `MachineInstr` предоставляет информацию о том,
какие из операндов инструкции являются регистрами, числами и адресами меток.
Данная абстракция удобна тем, что позволяет понять самые важные свойства
инструкции не вдаваясь в подробности того, какая именно это инструкция. В
дальнейшей работе мы будем работать с машинным кодом, разбитым на функции,
являющиеся списком `MachineInstr`. Инфраструктура LLVM позволяет легко
осуществить подобное разбиение, в результате которого мы получим MIR
представление исходного машинного кода, при этом не описывая вручную ни одну из
инструкций спецификации архитектуры RISC-V. Это значительно упрощает поддержку
большого числа расширений.

== Универсальная модель инструкции RISC-V

Ещё одним препядствием к простому поддержанию новых расширений RISC-V в
существующих инструментах является то, каким образом инструкциям из машинного
кода сопоставляется операции в LLVM IR. Чаще всего подъём кода происходит путём
индивидуальной обработки каждой из поддержанных инструкций в исходном коде. Это
означает, что в определённом месте исходного кода инструмента присутствует
обработка сотен краевых случаев (вообще говоря по одному на каждую поддержанную
инструкцию). В данной работе предлагается минимизировать число таких краевых
случаев путём разбиения всех поддержанных инструкций на типы (полученные из MIR
как описано в @mir-desc) и дальнейшего предоставления описания всех инструкций в
фиксированном виде для каждого из типов. Итого предлагается заменить обработку
подъёма каждой инструкции (число которых измеряется в сотнях) на обработку
нескольких классов инструкций и дальнейшей шаблонной подстановки LLVM IR кода,
соответствующего каджой инструкции из класса. Такой подход сильно упрощает
сопоставление LLVM IR каждой из инструкций и задаёт конкретный формат этого
сопоставления, что позволяет поддерживать новые инструкции в отрыве от исходного
кода и его краевых случаев.

== Собственное соглашение о вызовах

Кроме большого числа расширений RISC-V отличается от других архитектур наличием
нескольких соглашений о вызовах функций. Большинство существующих инструментов
для подъёма кода в LLVM IR описывают ABI подежриваемых исходных архитектур и при
работе с кодом, содержащим несколько функций, стараются восстанавливать
сигнатуру исходной функции при помощи таких инструментов как паттерн-матчинг. В
связи с наличием нескольких возможных соглашений о вызовах в RISC-V коде мы
будем избегать этого. Вместо восстановления сигнатуры функции в этой работе
предлагается ввести собственное соглашение о вызовах, которое будет скрывать за
собой ABI исходного кода.

