#import "/utils/todo.typ": TODO
#import "@preview/codly:1.3.0": *
#import "@preview/codly-languages:0.1.1": *
#show: codly-init.with()

= Исследование и построение решения задачи
В данной главе мы обсудим возможные решения проблем существующих лифтеров в LLVM
IR. Отличительной чертой предложенного подхода будет являться минимализация
ручного описания архитектуры.

== Использование описания архитектуры из LLVM <mir-desc>

Прежде всего мы решим проблемы поддержания низкоуровневой информации об
инструкциях, регистрах и расширениях. Как уже было сказано, многие существующие
инструмены поддерживают собственное описание инструкций для работы с машинным
кодом. Предлагается полностью решить эту проблему, переиспользовав уже
существующие описания. LLVM, являясь компиляторной инфраструктурой, обязан уметь
корректно порождать и читать машинный код. Большим плюсом этой платформы
является развитое описание всех инструкций и всех расширений RISC-V (Как и
подавляющего большинства других архитектур, таких как X86, ARM, MIPS и даже
SPIRV). LLVM обладает информацие о кодировках, операндах, семантике ассемблера
всех инструкций из большинства существующих расширений RISC-V. Вместо того,
чтобы описывать всю эту информацию вручную предлагается преиспользовать
существующее описание инструкций из LLVM. Большим плюсом такого подхода является
снижение вероятности ошибки. Все расширения, поддержанные в LLVM косвенно
тестируются компилятором `clang`. Это означает, что если в описании некого
расширения допущена ошибка, то компиляция под архитектуру процессора,
включающего это расширение либо произойдёт ошибка, либо исполнение программы
будет некорректным, что приведёт к мотивации исправить недочёт в описании для
стабильной работы компилятора `clang`. Таким образом в нашем инструменте будет
доступна корректная информация о всех расширениях RISC-V, поддержанных
компилятором `clang` (Таких расширений на момент написания данной работы больше
100).

Рассмотрим подробнее средства средства взаимодействия с машинным описанием,
предоставляемые библиотекой LLVM. Как уже было сказано во введении, MIR является
внутренним представлением машинного кода в LLVM. Самым важным из примитивов
машинной абстракции MIR является класс инструкции `MachineInstr`. Он
предоставляет такую информацию о конкретной инструкции в коде, как её тип, число
и типы её операндов и т.д, но является общим для инструкций из всех поддержанных
архитектур и расширений RISC-V. С помощью этого объекта можно определить
является ли инструкция передачей управления, работой с памятью или
арифметической операцией. Также `MachineInstr` предоставляет информацию о том,
какие из операндов инструкции являются регистрами, числами и адресами меток.
Данная абстракция удобна тем, что позволяет понять самые важные свойства
инструкции не вдаваясь в подробности того, какая именно это инструкция. В
дальнейшей работе мы будем работать с машинным кодом, разбитым на функции,
являющиеся списком `MachineInstr`. Инфраструктура LLVM позволяет легко
осуществить подобное разбиение, в результате которого мы получим MIR
представление исходного машинного кода, при этом не описывая вручную ни одну из
инструкций спецификации архитектуры RISC-V. Это значительно упрощает поддержку
большого числа расширений.

== Универсальная модель инструкции RISC-V

Ещё одним препядствием к простому поддержанию новых расширений RISC-V в
существующих инструментах является то, каким образом инструкциям из машинного
кода сопоставляется операции в LLVM IR. Чаще всего подъём кода происходит путём
индивидуальной обработки каждой из поддержанных инструкций в исходном коде. Это
означает, что в определённом месте исходного кода инструмента присутствует
обработка сотен краевых случаев (вообще говоря по одному на каждую поддержанную
инструкцию). В данной работе предлагается минимизировать число таких краевых
случаев путём разбиения всех поддержанных инструкций на типы (полученные из MIR
как описано в @mir-desc) и дальнейшего предоставления описания всех инструкций в
фиксированном виде для каждого из типов. Итого предлагается заменить обработку
подъёма каждой инструкции (число которых измеряется в сотнях) на обработку
нескольких классов инструкций и дальнейшей шаблонной подстановки LLVM IR кода,
соответствующего каджой инструкции из класса. Такой подход сильно упрощает
сопоставление LLVM IR каждой из инструкций и задаёт конкретный формат этого
сопоставления, что позволяет поддерживать новые инструкции в отрыве от исходного
кода и его краевых случаев.

Отдельно рассмотрим предлагаемый принцип шаблонизации инструкций RISC-V.
Конкретные детали будут различаться для разных классов инструкций, но структура
решения будет неизменно. Для осознания принципа разберём самый простой и самый
часто встречающийся класс инструкций -- арифметические инструкции или работа с
памятью. Данный класс инструкций предлагается назвать "регулярным" и для
сопоставления LLVM IR кода инструкциям этого класса предлагается использовать
функции LLVM IR. Другими словами каждой инструкции, например `ADD` мы
сопоставляем определение функции на LLVM IR по следующему принципу:
- Каждый входной операнд (регистр или число) становится аргументом этой функции.
- Каждый выходной операнд-регистр инструкции (Все инструкции имеют не более
  одного) становится возвращаемым значением этой функции.

Рассмотрим данный подход на примере инструкции `ADD` из 64-битного варианта
архитектуры RISC-V RV64I. В MIR данная инструкция может иметь вид, указанный в
@add-mir-code. Ей, по описанным выше правилам сопоставится функция из
@add-llvm-code. Далее при последовательном переводе иструкци MIR на место
инструкции `ADD` мы вставим вызов функции `@ADD`, передав текущие значения
входных регистров (`X11` и `X12`) как аргументы вызова и сохранив возращаемое
значение как новое значение регистра `X10` (см. @add-call-code).

#grid(columns: (50%, 50%), gutter: 5pt, [
#figure(caption: [Инструкция `ADD` в LLVM IR])[
#set text(size: 1.2em)
```MIR
        $X10 = ADD $X11, $X12
      ```
] <add-mir-code>
], [
#figure(caption: [Сопоставленная инструкции `ADD` функция LLVM IR])[
#set text(size: 1.2em)
```LLVM
      define i64 @ADD(i64 %rs1, i64 %rs2) {
        %4 = add i64 %rs1, %rs2
        ret i64 %4
      }

      ```
] <add-llvm-code>
])
#figure(caption: "Сигнатура поднятой функции на LLVM IR")[
#set text(size: 1.2em)
```LLVM
  ...
   %new_X10 = call i64 @ADD(i64 %X11, i64 %X12)
  ...

  ```
] <add-call-code>

== Собственное соглашение о вызовах

Кроме большого числа расширений RISC-V отличается от других архитектур наличием
нескольких соглашений о вызовах функций. Большинство существующих инструментов
для подъёма кода в LLVM IR описывают ABI подежриваемых исходных архитектур и при
работе с кодом, содержащим несколько функций, стараются восстанавливать
сигнатуру исходной функции при помощи таких инструментов как паттерн-матчинг. В
связи с наличием нескольких возможных соглашений о вызовах в RISC-V коде мы
будем избегать этого. Вместо восстановления сигнатуры функции в этой работе
предлагается ввести собственное соглашение о вызовах, которое будет скрывать за
собой ABI исходного кода.

Разберём предлагаемое решение. Для этого определим класс контекста (state) как
структуру, содержащую текущие значения используемых регистров RISC-V. В случае
архитектуры RV64IM это -- 32 регистра общего назначения с именами `X0-X31`.
Далее при подъёме каждой функции присвоим сигнатуру, в которой она принимает
указатель (ссылку) на наш класс текущего контекста и не возвращает ничего. Иными
словами, на языке C поднятая функция `foo` имела бы вид:

#codly(zebra-fill: none)
#figure(caption: "Сигнатура поднятой функции на языке C")[
```C
void foo(struct state *st);

```
]

Или эквивалентное представление на LLVM IR:

#figure(caption: "Сигнатура поднятой функции на LLVM IR")[
```LLVM
declare void @foo(ptr %state)

```
]

Поясним, как такой подход упрощает работу с ABI. Предположим, что в нашем
соглашении о вызовах аргументы вызова функции хранятся в регистрах `X10-X15`, а
возвращаемое значение сохраняется в регистр `X10` (Аналог `lp64` ABI). Тогда, в
процессе перевода кода в LLVM IR инструкции инициализации аргументных регистров
переведётся в обновление значений этих самых регистров в нашем классе контекста
(Вне зависимости от реального используемого функцией числа аргументов). После
этого, вызываемая функция получит указатель на этот контекст и далее будет
загружать значения регистров из контекста. Заметим, что если бы аргументными
регистрами являлись `X5-X10`, то в поднятии кода ничего бы не изменилось, вызывающая
функция в таком случае обновилда бы значения регистров с пятого по десятый в
контексте, а вызываемая использовала бы значения этих регистров из контекста. То
же верно и для возвращаемого значения функции, регистр возращаемого значения
будет обновлён в контексте вызываемой функцией и интерпретирован вызывающей
функцией как результат.

== Вывод

Таким образом мы установили три решения для трёх разных проблем, присутствующих
в существующих инструментах для подъёма кода в LLVM IR. Предложенный подход
позволяет значительно снизить сложность поддержки новых расширений RISC-V,
переиспользовав как можно больше средств, предоставляемых инфраструктурой LLVM.
Объём ручного описания архитектуры сведён к минимуму и включает в себя только
непосредственное сопоставление LLVM IR кода исходным инструкциям RISC-V.
