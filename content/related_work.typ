#import "/utils/todo.typ": TODO

= Обзор существующих решений
Наиболее распространёнными подходами к решению бинарной несовместимости явлются
бинарные трансляторы и эмуляторы. Рассмотрим оба понятия.

== Эмуляция
Эмуляторы -- инструменты, позволяющие исполнять машинный код другой архитектуры
при помощи симуляции всей исходной архитектуры, включая симуляцию регистров,
особенностей подсистемы памяти и конвеера исполнения. Эмуляторы часто являются
самым простым способом исполнения кода несовместимой архитектуры. Такой подход
отличается невысокой производительностью, следующей из затрат на точную
симуляцию всех параметров исходной системы.

== Бинарная трансляция
Бинарная трансляция -- процесс преобразования бинарного кода исходной
архитектуры в бинарный код целевой архитектуры. Бинарная трансляция может
происходить на уровне процессорных микросхем, либо с помощью программ,
называемых бинарными трансляторами. В данной работе мы будем фокусироваться на
програмной бинарной трансляции. Такие трансляторы можно разделить на два типа:
Статические и динамические.
- Статическими бинарными трансляторами называются программы, принимающие на вход
  исполняемый бинарный файл исходной архитектуры целиком и преобразующие его в
  исполняемый файл целевой архитектуры. В процессе статической бинарной трансляции
  процесс перевода кода на другую архитектуру и его исполнение разделены: Сначала
  переводится весь код целиком, после он может быть исполнен. Такой вид бинарной
  трансляции может быть выполнен без возможности исполнить исходный код. Этот
  подход усложняется тем, что не весь исполняемый код программы может быть
  доступен бинарному транслятору. Например, некоторые куски кода и метки могут
  достигаться программой через косвенные переходы (передача управления при помощи
  прыжка по адресу, записанному в регистре или в памяти), которые может быть
  тяжело или вовсе невозможно анализировать без предварительного исполнения. Часто
  статическая бинарная трансляция производится за счёт декомпиляции -- перевода
  кода в выскоуровневое представление (Например с помощью @ghidra), обратной
  инженерии и последующей компиляции на целевую архитектуру.
- Динамические бинарные трансляторы -- программы, переводящие исходный машинный
  код на целевую архитектуру по необходимости. В этом подходе транслируется
  маленький кусок кода (чаще всего в пределах одного базового блока), после чего
  сразу исполняется на целевой архитектуре и контекст исполнения (значения
  регистров и памяти) сохраняется. При достижении инструкций перехода начинает
  транслироваться новый кусок кода или (в случае циклов) исполняться уже
  странслированный. Стоит отметить, что динамическая трансляция отличается от
  эмуляции архитектуры, ведь при таком подходе инструкции исходной архитектуры
  напрямую переводятся в инструкции целевой архитектуры, без симуляции такого
  контекста исходной архитектуры, как регистров, таблицы прерываний и специфики
  памяти. Это означает, что динамические бинарные трансляторы в среднем обладают
  большей производительностью чем эмуляторы, что позволяет применять их в более
  широком спектре задач. Приведём наиболее иллюстративные примеры динамических
  бинарных трансляторов:
  - Rosetta -- транслятор, который использовался компанией Apple для упрощения
    перехода их персональных компьютеров с Архитектуры PowerPC на X86 в 2005 году
    @rosetta.
  - IA-32 Execution Layer -- динамический бинарный транслятор, разработанный
    компанией Intel в 2003 году для производительного исполнения 32-битных программ
    на более новой 64-битной архитектуре Itanium @ia32el.
  - Berberis -- относительно новый инструмент, разработанный Google для запуска
    RISC-V Android приложений на устройствах с архитектурой X86_64 @berberis.

Теперь, получив общее представление о эмуляторах и бинарных трансляторах, мы
можем поговорить о способах подъёма машинный код в высокоуровневое
представление.

== Лифтеры в высокоуровневое представление
Большая часть бинарных трансляторов работает за счёт прямого сопоставления
инструкций и регистров целевой архитектуры инструкциям и регистрам исходной (см
@rosetta, @qemu и @berberis). Такой подход делает процесс бинарной трансляции
уникальным для каждого сочетания из исходной и целевой архитектур, что делает
поддержку новых целевых архитектур сложной задачей. Подъём кода в промежуточное
представление и его перекомпиляция на целевую архитектуру -- принцип,
позволяющий сильно упростить добавление новых целевых архитектур. Такой подход
можно применять как для статической, так и для динамической бинарной трансляции.
Наиболее популярными высокоуровневыми представлениями для подъёма кода являются
язык C и LLVM IR. Мы сфокусируемся на подъёме в машинного кода в LLVM IR, т.к.
подъём в C чаще применяется для обратной разработки, а не для бинарной
трансляции. Рассмотрим существующие инструменты для получения LLVM IR из
машинного кода:
- llvm-mctoll -- инструмент, разработанный компанией Microsoft @mctoll. Проект
  хорошо поддерживает подъём из X86 и ARM кода. Поддержка других архитектур
  отсутствует, что делает невозможным его использование для архитектуры RISC-V.
- mcsema -- другой популярный инструмент для подъёма кода в LLVM IR. Данная
  программа поддерживает следующие архитектуры: X86, ARM и SPARC, таким образом
  снова невозможно её использование для наших задач @mcsema.
- rellume -- единственный инструмент, способный поднимать не только код под ARM и
  X86, но и подмножество RISC-V @rellume. К сожалению, поддерживается только 197
  инструкций из всей спецификации архитектуры RISC-V и поддержка новых расширений
  в этом инструменте осложнена.
- biotite -- новый инструмент для подъёма кода, работающий с подмножеством RISC-V
  кода, но требующий информацию об исходном коде программы, что не подходит для
  наших задач @biotite.

== Вывод
После проведения анализа существующих инструментов для подъёма машинного кода в
LLVM IR были выявлены закономерности, которым подчиняются все существующие
решения. Оценка присущих им недостатков позволяет выявить возможное направление
дальнейшего развития этого направления.

Список инструментов, позволяющих поднимать код архитектуры RISC-V в LLVM IR мал
и включает в себя всего две программы (см. @rellume и @biotite). Подавляющее
большинство существующих решений поддерживают только архитектуры X86 и ARM.

Существующие инструменты подъёма кода открытой архитектуры RISC-V работают лишь
с небольшим её подмножеством. Проблема в поддержке всего подмножества RISC-V
заключается в её модульной расширяемой системе. С появлением новых стандартных и
вендорских расширений требуется модификация исходного кода лифтера и ручная
обработка новых инструкций. Эта задача становится сложной из-за того, что в
большинстве существующих решений всем инструкциям или их комбинациям исходной
архитектуры вручную сопоставляются инструкции LLVM IR, что порождает большое
число краевых случаев и возможных комбинаций для распознавания паттернов.

Поддержка новых расширений RISC-V затруднена необходимостью работы с
низкоуровневой информацией о регистрах и инструкциях. Такая информация
необходима для декодирования бинарного машинного кода. Многие из представленных
инструментов используют собственное описание инструкций и работают с ними через
это самое описание. Например, в @biotite всем поддержанным инструкциям вручную
сопоставляются их названия и возможные операнды. Далее бинарные файлы
декодируются в два шага:
- С помощью программы-дизассемблера исходный машинный код переводится в своё
  текстовое представление
- Далее, используя информацию о названиях инструкций и их операндах, полученный
  текст дизассемблера разбивается на инструкции
Очевидным является то, что ручное описание каждой инструкции является предметом
потенциальных ошибок. В контексте расширяемой архитектуры RISC-V это значит
увеличение числа ошибок с увеличением числа поддерживаемых расширений. Также
описание синтаксиса некоторых инструкций (например векторных) требует большой
работы.

Таким образом, существующие инструменты для подъёма кода RISC-V в LLVM IR
поддерживают лишь небольшое подмножество инструкций этой архитектуры. Внедрение
новых расширений затруднено и архитектура проектов не позволяет работы с
вендорскими расширениями без модификации исходного кода и перевыпуска
инструмента.